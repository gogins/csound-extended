<html>
<head>
<style>
    ::-webkit-scrollbar
    {
        width:10px;
    }
    ::-webkit-scrollbar-track-piece
    {
        background-color:transparent;
    }
    ::-webkit-scrollbar-corner
    {
        background-color:transparent;
    }
.dg {
        font-family: Monaco, sans-serif;
        font-size:8pt;
    }
</style>
</script>
<script>
</script>
<script src='js/csound_loader.js'></script>
<script src='js/sprintf.js'></script>
<script src='js/numeric.js'></script>
<script src="js/three.js"></script>
<script src='js/tinycolor.js'></script>
<script src='js/Silencio.js'></script>
<script src="js/TrackballControls.js"></script>
<script src='js/ChordSpace.js'></script>
<script src='js/numeric.js'></script>
<script src='js/HarmonyIFS.js'></script>
<script src="js/dat.gui.js"></script>
</head>
<body style="background:black;">
<canvas id="canvas" style="block;height:100vh;width:100vw">
</canvas>
<textarea id="console" style="position:absolute;left:1vw;top:1vw;width:50vw;height:98vh;color:SkyBlue;background-color:transparent;border:none;text-align:left;font-size:8.25px;overflow:auto;cursor:none;"><textarea>
<script>
<canvas id="canvas" style="block;height:100vh;width:100vw">
</canvas>
<textarea id="console" style="position:absolute;left:1vw;top:1vw;width:50vw;height:98vh;color:SkyBlue;background-color:transparent;border:none;text-align:left;font-size:8.25px;overflow:auto;cursor:none;"></textarea>
<script>
var title = 'Harmony IFS'
try {
    var fs = require("fs");
    var git = require('git-rev-sync');
    var soundfile_name = sprintf("HarmonyIfs-%s.wav",  git.short());
} catch(e) {
    console.log(e);
}
window.onerror = function(message, url, line) {
  console.trace();
  csound.message(message + '\n' + url + '\n' + line + '\n');
};

var generate = function() {
    try {
        csound.message("Generating score...\n");
        trichord_optis = ChordSpace.allOfEquivalenceClass(3, "OPTI");
        trichord_opttis = ChordSpace.allOfEquivalenceClass(3, "OPTTI");
        tetrachord_optis = ChordSpace.allOfEquivalenceClass(4, "OPTI");
        tetrachord_opttis = ChordSpace.allOfEquivalenceClass(4, "OPTTI");
        console.log(tetrachord_optis.length);
        let harmony_ifs = new HarmonyIFS.ScoreAttractor(3, 60., 48., .02);
        harmony_ifs.chord_space_group.list(true, true);
        let chord = ChordSpace.chordForName("CM");
        let dominant = ChordSpace.chordForName("GM");
        console.log(chord.information())
        let chord_point = harmony_ifs.chord_space_group.fromChord(chord);
        let dominant_point = harmony_ifs.chord_space_group.fromChord(dominant);
        window.score = harmony_ifs.score;
        csound.message(sprintf("\nMajor P:    %12.4f\n", chord_point.P));
        csound.message(sprintf("\nDominant P: %12.4f\n", dominant_point.P));
        // Must contract QUITE A BIT in order to converge to these interpolation points!
        // This is supposed to elaborate on IM7 - iim7 - V7 - IM7.
        harmony_ifs.add_interpolation_point( 0, chord_point.P,    1,  0, .001, .001, .001);
        harmony_ifs.add_interpolation_point(10, chord_point.P,    0,  2, .001, .001, .001);
        harmony_ifs.add_interpolation_point(20, dominant_point.P, 1, -5, .001, .001, .001);
        harmony_ifs.add_interpolation_point(30, chord_point.P,    1,  0, .001, .001, .001);
        harmony_ifs.initialize_hutchinson_operator();
        // Add some additional transformation elements to fill out chords with
        // actual voices.
        harmony_ifs.hutchinson_operator[0][4][4] =  0.85;
        harmony_ifs.hutchinson_operator[0][4][7] = -1;
        harmony_ifs.hutchinson_operator[1][4][4] =  0.85;
        harmony_ifs.hutchinson_operator[1][4][7] =  1;
        harmony_ifs.hutchinson_operator[2][4][4] =  0.85;
        harmony_ifs.hutchinson_operator[2][4][7] = -1;
        harmony_ifs.hutchinson_operator[2][4][4] =  0.85;
        harmony_ifs.hutchinson_operator[2][4][7] = -1;
        let A = 45. * Math.PI / 180.;
        csound.message("A: %9.4f\n", A);
        // Add a rotation in the velocity/key plane, and the key/instrument
        // plane.
        let t = 0;
        let P = 1;
        let k = 4;
        let v = 5;
        let c = 6;
        let rotation1 = numeric.identity(8);
        rotation1[k][k] = Math.cos(A);
        rotation1[k][v] = - Math.sin(A);
        rotation1[v][k] = Math.sin(A);
        rotation1[v][v] = Math.cos(A);
        harmony_ifs.hutchinson_operator.push(rotation1);
        let rotation2 = numeric.identity(8);
        rotation2[k][k] = Math.cos(A);
        rotation2[k][c] = - Math.sin(A);
        rotation2[c][k] = Math.sin(A);
        rotation2[c][c] = Math.cos(A);
        harmony_ifs.hutchinson_operator.push(rotation2);
        // Add a rotation in the time/set-class plane.
        let rotation3 = numeric.identity(8);
        rotation3[t][t] = Math.cos(A);
        rotation3[t][P] = - Math.sin(A);
        rotation3[P][t] = Math.sin(A);
        rotation3[P][P] = Math.cos(A);
        // Uncomment this to see how rotating in the time-harmony plane breaks
        // the fractal interpolation function.
        // harmony_ifs.hutchinson_operator.push(rotation3);
        harmony_ifs.generate(7);
        score.setDuration(180);
        // Pianoteq misbehaves if we start right at time 0.
        for (var i = 0; i < score.data.length; i++) {
            var event = score.data[i];
            event.time = event.time + 4;
        }
        score.setScale(Silencio.Event.CHANNEL, 1, 0);
        csound.message("Plotting score...\n");
        score.draw3D(document.getElementById("canvas"));
        csound.message(sprintf("Generated %d notes.\n", harmony_ifs.score.size()));
        console.log(score.toString());
    } catch(err) {
      csound.message(err.name + ': ' + err.message + ' ' + err.line + '\n');
      console.trace();
    }
};

// Message level for standard (terminal) output. Takes the sum of any of the following values:
// 1 = note amplitude messages
// 2 = samples out of range message
// 4 = warning messages
// 128 = print benchmark information
// And exactly one of these to select note amplitude format:
// 0 = raw amplitudes, no colours
// 32 = dB, no colors
// 64 = dB, out of range highlighted with red
// 96 = dB, all colors
// 256 = raw, out of range highlighted with red
// 512 = raw, all colours
var render = function(soundfile, post_process) {
    var csd = document.getElementById('csd').value;
    var csound_score = score.toCsoundScore();
    csound_score = csound_score.concat("\n</CsScore>");
    csd = csd.replace("</CsScore>", csound_score);
    csound.message("Playing...");
    csound.setOption(sprintf('-m195'));
    csound.setOption('--nodisplays');
    csound.setOption('-R');
    csound.setOption('-W');
    csound.setOption('-f');
    csound.setOption('-o' + soundfile_name);
    //csound.setOption('-odac');
    csound.setMetadata("artist", "Michael Gogins");
    csound.setMetadata("copyright", "Copyright 2020 by Michael Gogins");
    csound.setMetadata("performer", "Michael Gogins");
    csound.setMetadata("title", "Harmony IFS");
    csound.setMetadata("album", "Silence");
    csound.setMetadata("track", "1");
    csound.setMetadata("tracknumber", "1");
    csound.setMetadata("date", "2020");
    csound.setMetadata("publisher", "Irreducible Productions ASCAP");
    csound.setMetadata("comment", "Graph of fractal approximation function in chord symmetry space.");
    csound.setMetadata("license", "CC BY-NC-SA");
    csound.setMetadata("genre", "Electroacoustic");
    if (soundfile === true) {
        csound.setOutput("HarmonyIfsTest.wav", "wav", "float");
    } else {
        csound.setOutput("dac", "wav", "float");
    }
    fs.writeFileSync("HarmonyIFsTest1-generated.csd", csd);
    csound.compileCsdText(csd);
    csound.message("Rendering...");
    csound.start();
    if (post_process == true) {
        csound.performAndPostProcess();
    } else {
        csound.perform();
    }
    updateScoreTime();
}

var render_audio = function() {
    render(false, false);
}

var render_soundfile = function() {
    render(true, false);
}

var render_soundfile_and_postprocess = function() {
    render(true, true);
}

var stop = function() {
    Silencio.saveDatGuiJson(gui);
    csound.stop();
}

var updateScoreTime = function() {
    var score_time = csound.getScoreTime();
    setTimeout(updateScoreTime, 200);
    score.progress3D(score_time);
};

var parameters = {
    gk_FMWaterBell_level: 15,
    gi_FMWaterBell_attack: 0.002,
    gi_FMWaterBell_release: 0.01,
    gi_FMWaterBell_exponent: 15,
    gi_FMWaterBell_sustain: 20,
    gi_FMWaterBell_sustain_level: .1,
    gk_FMWaterBell_index: .5,
    gk_FMWaterBell_crossfade: .5,
    gk_FMWaterBell_vibrato_depth: 0.05,
    gk_FMWaterBell_vibrato_rate: 6,
    gk_Bower_level: 0.5,
    gk_Bower_pressure: 0.25,
    gk_Blower_grainDensity: .150,
    gk_Blower_grainDuration: .2,
    gk_Blower_grainAmplitudeRange: .1,
    gk_Blower_grainFrequencyRange: .033,
    gk_Blower_level: 0.5,
    gk_Buzzer_harmonics: 15,
    gk_Buzzer_level: 0.5,
    gk_Droner_partial1: 0.1,
    gk_Droner_partial2: 0.1,
    gk_Droner_partial3: 0.1,
    gk_Droner_partial4: 0.1,
    gk_Droner_partial5: 0.1,
    gk_Droner_level: 0.5,
    gk_Phaser_ratio1: 1,
    gk_Phaser_ratio2: .3333334,
    gk_Phaser_index1: 1,
    gk_Phaser_index2: .0125,
    gk_Phaser_level: 0.5,
    gk_PianoteqOut_level: 0.5,
    gk_Shiner_level: 0.5,
    gk_Sweeper_britel: 0,
    gk_Sweeper_briteh: 2.9,
    gk_Sweeper_britels: .2 / 3,
    gk_Sweeper_britehs: 2.5 / 2,
    gk_Sweeper_level: 0.5,
    gk_ZakianFlute_level: 0,
    gk_Reverb_feedback: .975,
    gk_Reverb2_feedback: .7,
    gk_MasterOutput_level: .4,
    gk_overlap: 0.05,
    generate: window.generate,
    render_audio: window.render_audio,
    render_soundfile: window.render_soundfile,
    render_soundfile_and_postprocess: window.render_soundfile_and_postprocess,
    stop: window.stop,
};

var handleMessage = function(message) {
    let messages_textarea = document.getElementById("console");
    let existing = messages_textarea.value;
    messages_textarea.value = existing + message;
    messages_textarea.scrollTop = messages_textarea.scrollHeight;
}

var default_json = {
  "preset": "Default",
  "remembered": {
    "Default": {
      "0": {
        "gk_overlap": 5.504950495049505,
        "gk_Reverb_feedback": 0.7731258840169731,
        "gk_Reverb2_feedback": 0.5691378592253228,
        "gk_MasterOutput_level": -20,
        "gi_FMWaterBell_attack": 0.002936276551436901,
        "gi_FMWaterBell_release": 0.022698875468554768,
        "gi_FMWaterBell_exponent": 12.544773011245312,
        "gi_FMWaterBell_sustain": 5.385256143273636,
        "gi_FMWaterBell_sustain_level": 0.08267388588088297,
        "gk_FMWaterBell_crossfade": 0.48250728862973763,
        "gk_FMWaterBell_index": 1.1401499375260309,
        "gk_FMWaterBell_vibrato_depth": 0.2897954989209742,
        "gk_FMWaterBell_vibrato_rate": 4.762100503545371,
        "gk_FMWaterBell_level": 37.0,
        "gk_Phaser_ratio1": 1,
        "gk_Phaser_ratio2": 0.3333334,
        "gk_Phaser_index1": 1,
        "gk_Phaser_index2": 2,
        "gk_Phaser_level": 8.5, //14.608203677510609,
        "gk_Bower_pressure": 3.050919377652051,
        "gk_Bower_level": -12.677504515770458,
        "gk_Droner_partial1": 0.11032374600527997,
        "gk_Droner_partial2": 0.4927052938724468,
        "gk_Droner_partial3": 0.11921634014172572,
        "gk_Droner_partial4": 0.06586077532305128,
        "gk_Droner_partial5": 0.6616645824649159,
        "gk_Droner_level": 0.8392385716270638,
        "gk_Sweeper_britel": 0.2773844231570179,
        "gk_Sweeper_briteh": 3.382178217821782,
        "gk_Sweeper_britels": 0.19575671852899576,
        "gk_Sweeper_britehs": 0.8837340876944837,
        "gk_Sweeper_level": 7.366336633663366,
        "gk_Buzzer_harmonics": 2.608203677510608,
        "gk_Buzzer_level": 18, // 24.74681753889675,
        "gk_Shiner_level": 16.056577086280058,
        "gk_Blower_grainDensity": 79.99177885109444,
        "gk_Blower_grainDuration": 0.2,
        "gk_Blower_grainAmplitudeRange": 87.88408180043162,
        "gk_Blower_grainFrequencyRange": 30.596081700708627,
        "gk_Blower_level": -2,
        "gk_ZakianFlute_level": 0,
        "gk_PianoteqOut_level": 4,
      }
    }
  },
  "closed": false,
  "folders": {
    "Master": {
      "preset": "Default",
      "closed": true,
      "folders": {}
    },
    "FMWaterBell": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Phaser": {
      "preset": "Default",
      "closed": true,
      "folders": {}
    },
    "Bower": {
      "preset": "Default",
      "closed": true,
      "folders": {}
    },
    "Droner": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Sweeper": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Buzzer": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Shiner": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Blower": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    },
    "Pianoteq": {
      "preset": "Default",
      "closed": false,
      "folders": {}
    }
  }
};

window.onload = function() {
    get_csound(handleMessage);
    console.info = csound.message;
    try {
        var temporary_json = Silencio.restoreDatGuiJson(default_json);
        //default_json = temporary_json;
        gui = new dat.GUI({load: default_json, width: 300});
        csound.message("Restored Csound instrument parameters.\n");
    } catch(e) {
        csound.message("Failed to restore Csound instrument parameters.\n");
        gui = new dat.GUI({width: 400});
    }
    gui.remember(parameters);
    gui.add(parameters, 'generate').name('Generate [Ctrl-G]');
    gui.add(parameters, 'render_audio').name('Render audio [Ctrl-A]');
    gui.add(parameters, 'render_soundfile').name('Render soundfile');
    gui.add(parameters, 'render_soundfile_and_postprocess').name('Render/post [Ctrl-P]');
    gui.add(parameters, 'stop').name('Stop [Ctrl-S]');
    var Master = gui.addFolder('Master');
    add_slider(Master, 'gk_overlap', 0, 20);
    add_slider(Master, 'gk_Reverb_feedback', 0, 1);
    add_slider(Master, 'gk_Reverb2_feedback', 0, 1);
    add_slider(Master, 'gk_MasterOutput_level', -40, 40);
    var FMWaterBell = gui.addFolder('FMWaterBell');
    add_slider(FMWaterBell, 'gi_FMWaterBell_attack', 0, .1);
    add_slider(FMWaterBell, 'gi_FMWaterBell_release', 0, .1);
    add_slider(FMWaterBell, 'gi_FMWaterBell_exponent', -30, 30);
    add_slider(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 20);
    add_slider(FMWaterBell, 'gi_FMWaterBell_sustain_level', 0, 1);
    add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 1);
    add_slider(FMWaterBell, 'gk_FMWaterBell_index', 0, 15);
    add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 10);
    add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 10);
    add_slider(FMWaterBell, 'gk_FMWaterBell_level',-40, 40);
    var Phaser = gui.addFolder('Phaser');
    add_slider(Phaser, 'gk_Phaser_ratio1', 0, 5);
    add_slider(Phaser, 'gk_Phaser_ratio2', 0, 5);
    add_slider(Phaser, 'gk_Phaser_index1', 0, 15);
    add_slider(Phaser, 'gk_Phaser_index2', 0, 15);
    add_slider(Phaser, 'gk_Phaser_level', -40, 40);
    var Bower = gui.addFolder('Bower');
    add_slider(Bower, 'gk_Bower_pressure', 0, 5);
    add_slider(Bower, 'gk_Bower_level', -40, 40);
    var Droner = gui.addFolder('Droner');
    add_slider(Droner, 'gk_Droner_partial1', 0, 1);
    add_slider(Droner, 'gk_Droner_partial2', 0, 1);
    add_slider(Droner, 'gk_Droner_partial3', 0, 1);
    add_slider(Droner, 'gk_Droner_partial4', 0, 1);
    add_slider(Droner, 'gk_Droner_partial5', 0, 1);
    add_slider(Droner, 'gk_Droner_level', -40, 40);
    var Sweeper = gui.addFolder('Sweeper');
    add_slider(Sweeper, 'gk_Sweeper_britel', 0, 4);
    add_slider(Sweeper, 'gk_Sweeper_briteh', 0, 4);
    add_slider(Sweeper, 'gk_Sweeper_britels', 0, 4);
    add_slider(Sweeper, 'gk_Sweeper_britehs', 0, 4);
    add_slider(Sweeper, 'gk_Sweeper_level', -40, 40);
    var Buzzer = gui.addFolder('Buzzer');
    add_slider(Buzzer, 'gk_Buzzer_harmonics', 0, 20);
    add_slider(Buzzer, 'gk_Buzzer_level', -40, 40);
    var Shiner = gui.addFolder('Shiner');
    add_slider(Shiner, 'gk_Shiner_level', -40, 40);
    var Blower = gui.addFolder('Blower');
    add_slider(Blower, 'gk_Blower_grainDensity', 0, 400);
    add_slider(Blower, 'gk_Blower_grainDuration', 0, .5);
    add_slider(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
    add_slider(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
    add_slider(Blower, 'gk_Blower_level', -40, 40);
    var Flute = gui.addFolder('Zakian Flute');
    add_slider(Flute, 'gk_ZakianFlute_level', -40, 40);
    var Pianoteq = gui.addFolder('Pianoteq');
    add_slider(Pianoteq, 'gk_PianoteqOut_level', -40, 40);
    gui.revert();
    document.addEventListener("keydown", function (e) {
        var e_char = String.fromCharCode(e.keyCode || e.charCode);
        if (e.ctrlKey === true) {
            if        (e_char === 'H') {
                var console = document.getElementById("console");
                if (console.style.display === "none") {
                    console.style.display = "block";
                } else {
                    console.style.display = "none";
                }
                gui.closed = true;
                gui.closed = false;
            } else if (e_char === 'G') {
                generate();
            } else if (e_char === 'P') {
                parameters.play();
            } else if (e_char === 'S') {
                parameters.stop();
            }
        }
    });
};

var gk_update = function(name, value) {
  var numberValue = parseFloat(value);
  csound.setControlChannel(name, numberValue);
}

var add_slider = function(gui_folder, token, minimum, maximum, name) {
    var on_parameter_change = function(value) {
        gk_update(token, value);
    };
    gui_folder.add(parameters, token, minimum, maximum).onChange(on_parameter_change);
};

window.addEventListener("unload", function(event) {
    parameters.stop();
    nw_window.close();
});

</script>
<textarea class="code" id="csd" hidden rows=24 cols=80>
<CsoundSynthesizer>
<CsOptions>
-dm195
</CsOptions>
<CsInstruments>
; Change to 96000 with 1 ksmps for final rendering.
sr = 48000
ksmps = 100
nchnls = 2
0dbfs = 8000000

; Ensure the same random stream for each rendering.
; rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.

;seed  81814
;seed  818145
seed  88818145

connect "Blower", "outleft", "Reverb", "inleft"
connect "Blower", "outright", "Reverb", "inright"
connect "Bower", "outleft", "Reverb", "inleft"
connect "Bower", "outright", "Reverb", "inright"
connect "Buzzer", "outleft", "Reverb", "inleft"
connect "Buzzer", "outright", "Reverb", "inright"
connect "Droner", "outleft", "Reverb", "inleft"
connect "Droner", "outright", "Reverb", "inright"
connect "FMWaterBell", "outleft", "Reverb2", "inleft"
connect "FMWaterBell", "outright", "Reverb2", "inright"
connect "Phaser", "outleft", "Reverb", "inleft"
connect "Phaser", "outright", "Reverb", "inright"
connect "PianoteqOut", "outleft", "MasterOutput", "inleft"
connect "PianoteqOut", "outright", "MasterOutput", "inright"
connect "Sweeper", "outleft", "Reverb", "inleft"
connect "Sweeper", "outright", "Reverb", "inright"
connect "Shiner", "outleft", "Reverb", "inleft"
connect "Shiner", "outright", "Reverb", "inright"
connect "ZakianFlute", "outleft", "Reverb", "inleft"
connect "ZakianFlute", "outright", "Reverb", "inright"
connect "Reverb", "outleft", "MasterOutput", "inleft"
connect "Reverb", "outright", "MasterOutput", "inright"
connect "Reverb2", "outleft", "MasterOutput", "inleft"
connect "Reverb2", "outright", "MasterOutput", "inright"

alwayson "Controls"
alwayson "PianoteqOut"
alwayson "Reverb"
alwayson "Reverb2"
alwayson "MasterOutput"

gk_overlap init 4.5

prealloc 1, 50
prealloc 2, 50
prealloc 3, 50
prealloc 4, 50
prealloc 5, 50
prealloc 6, 50
prealloc 7, 50
prealloc 8, 20
prealloc 9, 20
prealloc 11, 1
prealloc 12, 1
prealloc 13, 1

giPianoteq vstinit "/home/mkg/Pianoteq_6.so", 1

instr PianoteqNote
i_instrument = p1
i_time = p2
i_duration = p3 + i(gk_overlap)
p3 = i_duration
i_midikey = p4 - 12
i_midivelocity = p5
i_phase = p6
i_pan = p7
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
i_pitchclass = i_midikey % 12
i_hertz cpsmidinn i_midikey
i_amplitude = ampdb(i_midivelocity)
ichannel = 0
vstnote giPianoteq, ichannel, i_midikey, i_midivelocity, i_duration
prints "PIanoteqNote   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Buzzer_harmonics init 15
gk_Buzzer_level init .5
instr Buzzer
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
;xtratim iattack + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
;asignal gbuzz kenvelope, ihertz, 3, gk_FirstHarmonic, gk_DistortFactor, gisine
isine ftgenonce 0, 0, 65536, 10, 1
gk_Harmonics = gk_Buzzer_harmonics
asignal buzz kenvelope, ihertz, gk_Harmonics, isine
asignal = asignal * 3
;asignal vco2 kenvelope, ihertz, 12
;asignal poscil3 kenvelope, ihertz, giharmonics
;asignal distort asignal, gk_DistortFactor * .4, giwaveshaping
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Buzzer_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Buzzer         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

//////////////////////////////////////////////
// Original by Steven Yi.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
gk_FMWaterBell_level init 0
gi_FMWaterBell_attack init 0.002
gi_FMWaterBell_release init 0.01
gi_FMWaterBell_sustain init 20
gi_FMWaterBell_sustain_level init .1
gk_FMWaterBell_index init .5
gk_FMWaterBell_crossfade init .5
gk_FMWaterBell_vibrato_depth init 0.05
gk_FMWaterBell_vibrato_rate init 6
gk_FMWaterBell_midi_dynamic_range init 127
gi_FMWaterBell_cosine ftgen 0, 0, 65536, 11, 1
instr FMWaterBell
i_instrument = p1
i_time = p2
i_duration = p3
; One of the envelopes in this instrument should be releasing, and use this:
i_sustain = 1000
;xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
p3 = p3 + gi_FMWaterBell_attack + gi_FMWaterBell_release
i_midi_key = p4
i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = -20
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
k_gain = ampdb(gk_FMWaterBell_level)
a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
;a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 0
a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, 1, gi_FMWaterBell_release, 0
; ares transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...
; a_envelope transegr 0, gi_FMWaterBell_attack, 12, 1, i_sustain, 12, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 12, 0
a_signal = a_signal * i_amplitude * a_envelope * k_gain
;_signal = a_signal * i_amplitude * k_gain
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "FMWaterBell    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
; printks "FMWaterBell    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_Phaser_ratio1 init 1
gk_Phaser_ratio2 init 1/3
gk_Phaser_index1 init 1
gk_Phaser_index2 init 0.0125
gk_Phaser_level init 0.5
instr Phaser
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 8
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
isine ftgenonce 0,0,65536,10,1
khertz = ihertz
ifunction1 = isine
ifunction2 = isine
a1,a2 crosspm gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, khertz, ifunction1, ifunction2
aleft, aright pan2 a1+a2, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft * kenvelope
aright = adamping * aright * kenvelope
kgain = ampdb(gk_Phaser_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Phaser         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Droner_partial1 init .1
gk_Droner_partial2 init .1
gk_Droner_partial3 init .1
gk_Droner_partial4 init .1
gk_Droner_partial5 init .1
gk_Droner_level init 0.5
gi_Droner_sine ftgen 0, 0, 65536, 10, 1, 0, .02
instr Droner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
k1 init .5
k2 init .05
k3 init .1
k4 init .2
k5 init .1
k6 init .05
k7 init .1
k8 init 0
k9 init 0
k10 init 0
k3 = gk_Droner_partial1
k4 = gk_Droner_partial2
k5 = gk_Droner_partial3
k6 = gk_Droner_partial4
k7 = gk_Droner_partial5
kwaveform init 0
iamp = ampdb(ivelocity)
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
asignal poscil3 1, ihertz, gi_Droner_sine
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
asignal = asignal * kenvelope * 10
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Droner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Droner         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Sweeper_britel init 0
gk_Sweeper_briteh init 2.9
gk_Sweeper_britels init .2 / 3
gk_Sweeper_britehs init 2.5 / 2
gk_Sweeper_level init 0.5
instr Sweeper
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity)
gisine ftgenonce 0, 0, 65536, 10, 1
gioctfn ftgenonce 0, 0, 65536, -19, 1, 0.5, 270, 0.5
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
;xtratim iattack + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
icps = ihertz
kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
ktonemoddep jspline 0.01,0.05,0.2
ktonemodrte jspline 6,0.1,0.2
ktone poscil3 ktonemoddep, ktonemodrte, gisine
kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
ibasfreq init icps
ioctcnt init 3
iphs init 0
a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gisine, gioctfn, ioctcnt, iphs
amod poscil3 0.25, ibasfreq*(1/3), gisine
arm = a1*amod
irnd1 = unirand(1)
irnd3 = unirand(3)
kmix expseg 0.001, 0.01, irnd1, irnd3+0.3, 0.001
kmix=.25
a1 ntrpol a1, arm, kmix
;a1 pareq a1/10, 400, 15, .707
;a1 tone a1, 500
kpanrte jspline 5, 0.05, 0.1
kpandep jspline 0.9, 0.2, 0.4
kpan poscil3 kpandep, kpanrte, gisine
a1,a2 pan2 a1, kpan
irnd01 = unirand(0.1)
a1 delay a1, irnd01
irnd011 = unirand(0.11)
a2 delay a2, irnd011
kenv linsegr 1, 1, 0
kenv = kenvelope
aleft = a1*kenv*.02
aright = a2*kenv*.02
adamping linsegr 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Sweeper_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Sweeper        i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Shiner_level init 0.5
instr Shiner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
;xtratim iattack + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
gk_Harmonics = 1 * 20
asignal vco2 kenvelope * 4, ihertz, 12
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Shiner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Shiner         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Blower_grainDensity init 150
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init .033
gk_Blower_level init 0.5
instr Blower
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
i_phase = p6
i_pan = p6
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
ifrequency = cpsmidinn(i_midikey)
iamplitude = ampdb(i_midivelocity) / 200
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; f1 0 65536 1 "hahaha.aif" 0 4 0
 ; f2 0 1024 7 0 224 1 800 0
 ; f3 0 8192 7 1 8192 -1
 ; f4 0 1024 7 0 512 1 512 0
 ; f5 0 1024 10 1 .3 .1 0 .2 .02 0 .1 .04
 ; f6 0 1024 10 1 0 .5 0 .33 0 .25 0 .2 0 .167
 ; a0 14 50
 ; p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
 ; Start Dur Amp Freq GrTab WinTab FqcRng Dens Fade
 ; i1 0.0 6.5 700 9.00 5 4 .210 200 1.8
 ; i1 3.2 3.5 800 7.08 . 4 .042 100 0.8
 ; i1 5.1 5.2 600 7.10 . 4 .0320 100 0.9
 ; i1 7.2 6.6 900 8.03 . 4 .021 150 1.6
 ; i1 21.3 4.5 1000 9.00 . 4 .031 150 1.2
 ; i1 26.5 13.5 1100 6.09 . 4 .121 150 1.5
 ; i1 30.7 9.3 900 8.05 . 4 .014 150 2.5
 ; i1 34.2 8.8 700 10.02 . 4 .14 150 1.6
igrtab ftgenonce 0, 0, 65536, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
iwintab ftgenonce 0, 0, 65536, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
iHz = ifrequency
ihertz = iHz
ip4 = iamplitude
ip5 = iHz
ip6 = igrtab
ip7 = iwintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = iamplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
if p3 == -1 goto indefinite
  goto non_indefinite
indefinite:
  p3 = 1000000
non_indefinite:
iattack = i(gk_overlap) * 2
idecay = i(gk_overlap) * 2
isustain = p3 - i(gk_overlap) * 2
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
; kamp linseg 0, ifade, 1, idur - 2 * ifade, 1, ifade, 0
kamp = kenvelope
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange,  gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aleft = aoutl * kamp * iamplitude
aright = aoutr * kamp * iamplitude
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Blower_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_ZakianFlute_midi_dynamic_range init 20
gk_ZakianFlute_level init 0
gk_ZakianFlute_pan init .5
gi_ZakianFLute_seed init .5
instr ZakianFlute
; Author: Lee Zakian
; Adapted by: Michael Gogins
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_overall_amps = 8
i_normalization = ampdb(-i_overall_amps) / 2
i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_ZakianFlute_level)
iattack = .002
isustain = p3
irelease = .3
p3 = iattack + isustain + irelease
iHz = cpsmidinn(i_midi_key)
kHz = k(iHz)
aenvelope transeg 1.0, 20.0, -10.0, 0.05
ip3 = (p3 < 3.0 ? p3 : 3.0)
if2 ftgenonce 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
if26 ftgenonce 0, 0, 65536, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
if27 ftgenonce 0, 0, 65536, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
if28 ftgenonce 0, 0, 65536, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
if29 ftgenonce 0, 0, 65536, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
if30 ftgenonce 0, 0, 65536, -10, 1229, 16, 34, 57, 32
if31 ftgenonce 0, 0, 65536, -10, 163, 31, 1, 50, 31
if32 ftgenonce 0, 0, 65536, -10, 4128, 883, 354, 79, 59, 23
if33 ftgenonce 0, 0, 65536, -10, 1924, 930, 251, 50, 25, 14
if34 ftgenonce 0, 0, 65536, -10, 94, 6, 22, 8
if35 ftgenonce 0, 0, 65536, -10, 2661, 87, 33, 18
if36 ftgenonce 0, 0, 65536, -10, 174, 12
if37 ftgenonce 0, 0, 65536, -10, 314, 13
iwtsin ftgenonce 0, 0, 65536, 10, 1
; parameters
; p4 overall amplitude scaling factor
ip4 init i_amplitude
; p5 pitch in Hertz (normal pitch range: C4-C7)
ip5 init iHz
; p6 percent vibrato depth, recommended values in range [-1., +1.]
ip6 init 0.5
; 0.0 -> no vibrato
; +1. -> 1% vibrato depth, where vibrato rate increases slightly
; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
; p7 attack time in seconds
; recommended value: .12 for slurred notes, .06 for tongued notes
; (.03 for short notes)
ip7 init .08
; p8 decay time in seconds
; recommended value: .1 (.05 for short notes)
ip8 init .08
; p9 overall brightness / filter cutoff factor
; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
ip9 init 5
; initial variables
iampscale = ip4 ; overall amplitude scaling factor
ifreq = ip5 ; pitch in Hertz
ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifiltcut tablei ip9, if2 ; lowpass filter cutoff frequency
iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
isustain = p3 - iattack - idecay
p3 = (isustain < 5/kr ? iattack+idecay+5/kr : p3) ; minimal sustain length
isustain = (isustain < 5/kr ? 5/kr : isustain)
iatt = iattack/6
isus = isustain/4
idec = idecay/6
iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
; vibrato block
; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
kvibdepth = kvibdepth* ivibdepth ; vibrato depth
kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibdepth = kvibdepth + kvibdepthr
ivibr1 = gi_ZakianFLute_seed ; vibrato rate
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ivibr2 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
if ip6 < 0 goto vibrato1
kvibrate linseg 2.5+ivibr1, p3, 4.5+ivibr2 ; if p6 positive vibrato gets faster
 goto vibrato2
vibrato1:
ivibr3 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2, p3-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
vibrato2:
kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate = kvibrate + kvibrater
kvib oscili kvibdepth, kvibrate, iwtsin
ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev2 = .003 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev3 = -.0015 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev4 = .012 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
kfreq = kHz * (1 + kfreqr) + kvib
if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
goto range4
; wavetable amplitude envelopes
range1: ; for low range tones
kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
0.172, idec, 0.053, idec, 0
kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
-0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
-0.035, idec, -0.020, idec, 0
kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
0.010, idec, 0.013, idec, 0
iwt1 = if26 ; wavetable numbers
iwt2 = if27
iwt3 = if28
inorm = 3949
goto end
range2: ; for low mid-range tones
kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
0.037, idec, 0.012, idec, 0
kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
-1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
-0.170, idec, -0.065, idec, 0
kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
0.174, idec, -0.027, idec, 0
iwt1 = if29
iwt2 = if30
iwt3 = if31
inorm = 27668.2
goto end
range3: ; for high mid-range tones
kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
idec, 0.031, idec, 0
kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
-0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
-0.003, idec, -0.023, idec, 0
kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
0.167, idec, -0.059, idec, 0
iwt1 = if32
iwt2 = if33
iwt3 = if34
inorm = 3775
goto end
range4: ; for high range tones
kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
idec, 0.028, idec, 0
kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
-0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
-0.071, idec, -0.019, idec, 0
kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
-0.024, idec, 0.002, idec, 0
iwt1 = if35
iwt2 = if36
iwt3 = if37
inorm = 4909.05
goto end
end:
kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp1 = kamp1 + kampr1
kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp2 = kamp2 + kampr2
kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp3 = kamp3 + kampr3
awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
awt2 poscil kamp2, kfreq, iwt2, iphase
awt3 poscil kamp3, kfreq, iwt3, iphase
asig = awt1 + awt2 + awt3
asig = asig*(iampscale/inorm)
kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
afilt tone asig, kcut
a_signal balance afilt, asig
i_attack = .002
i_sustain = p3
i_release = 0.01
xtratim i_attack + i_sustain + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "ZakianFlute    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Bower_midi_dynamic_range init 127
gk_Bower_attack init .0125
gk_Bower_release init .0125
gk_Bower_level init 0.5
gk_Bower_pressure init 0.25
instr Bower
if p3 == -1 goto indefinite
  //prints "Non-indefinite.\n"
  goto non_indefinite
indefinite:
  p3 = 1000000
  //prints "Indefinite.\n"
non_indefinite:
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Bower_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = -80
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Bower_level)
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
;xtratim iattack + idecay
iamp = i_amplitude
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(i_midi_key)
kamp = kenvelope
kfreq = ihertz
kpres = 0.25
krat rspline 0.006,0.988,1,4
kvibf = 4.5
kvibamp = 0
iminfreq = 30
isine ftgenonce 0,0,65536,10,1
aSig wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,isine,iminfreq
aleft, aright pan2 aSig / 7, k_space_left_to_right
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft * k_gain
aright = adamping * aright * k_gain
outleta "outleft", aleft
outleta "outright", aright
prints "Bower          i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
;printks "Bower          i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aleft)), dbamp(rms(aright))
endin

gk_PianoteqOut_level init .5
instr PianoteqOut
vstprogset  giPianoteq, 1
vstparamset giPianoteq, 0, .01
; vstparamset giPianoteq, 7, 1
vstparamset giPianoteq, 72, .01
vstparamset giPianoteq, 73, .01
vstparamset giPianoteq, 74, .01
vstparamset giPianoteq,  80, 0.0
vstparamset giPianoteq, 126, 0.0
vstinfo     giPianoteq
ainleft init 0.0
ainright init 0.0
aoutleft, aoutright vstaudio giPianoteq, ainleft, ainright
kgain = ampdb(gk_PianoteqOut_level)
aoutleft = aoutleft * kgain   * 1.3333334
aoutright = aoutright * kgain * 1.3333334
outleta "outleft", aoutleft
outleta "outright", aoutright
prints "PianoteqOut    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
prints "Waiting for PianoTeq to initialize...\n"
ires system_i 1, {{ sleep 15
}}, 0
endin

gk_Reverb_feedback init 0.975
gi_Reverb_delay_modulation init 0.875
gk_Reverb_frequency_cutoff init 15000
instr Reverb
aleft init 0
aright init 0
aleft inleta "inleft"
aright inleta "inright"
; aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]
aleft, aright reverbsc aleft, aright, gk_Reverb_feedback, gk_Reverb_frequency_cutoff, sr, gi_Reverb_delay_modulation
outleta "outleft", aleft
outleta "outright", aright
prints "Reverb         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Reverb2_feedback init 0.975
gi_Reverb2_delay_modulation init 0.875
gk_Reverb2_frequency_cutoff init 15000
instr Reverb2
aleft init 0
aright init 0
aleft inleta "inleft"
aright inleta "inright"
; aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]
aleft, aright reverbsc aleft, aright, gk_Reverb2_feedback, gk_Reverb2_frequency_cutoff, sr, gi_Reverb2_delay_modulation
outleta "outleft", aleft
outleta "outright", aright
prints "Reverb2        i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_CenterHz init 200
gk_Gain init 1
gk_Q init 0.7071067 ; sqrt(.5)
instr ParametricEQ
aleft inleta "inleft"
aright inleta "inright"
aleft pareq aleft, gk_CenterHz, ampdb(gk_Gain), gk_Q, 0
aright pareq aright, gk_CenterHz, ampdb(gk_Gain), gk_Q, 0
outleta "outleft", aleft
outleta "outright", aright
prints "ParametricEQ   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_MasterOutput_level init .5
instr MasterOutput
aleft inleta "inleft"
aright inleta "inright"
kgain = ampdb(gk_MasterOutput_level)
outs aleft * kgain, aright * kgain
; fout "ScoreGraphTest.wav", 16, aleft, aright
prints "MasterOutput   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
endin

instr Controls
k_active chnget "gk_Bower_pressure"
if k_active == 0 goto off_label
prints "Controls on    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
    gk_FMWaterBell_level chnget "gk_FMWaterBell_level"
    gi_FMWaterBell_attack chnget "gi_FMWaterBell_attack"
    gi_FMWaterBell_exponent chnget "gi_FMWaterBell_exponent"
    gi_FMWaterBell_release chnget "gi_FMWaterBell_release"
    gi_FMWaterBell_sustain chnget "gi_FMWaterBell_sustain"
    gi_FMWaterBell_sustain_level chnget "gi_FMWaterBell_sustain_level"
    gk_FMWaterBell_index chnget "gk_FMWaterBell_index"
    gk_FMWaterBell_crossfade chnget "gk_FMWaterBell_crossfade"
    gk_FMWaterBell_vibrato_depth chnget "gk_FMWaterBell_vibrato_depth"
    gk_FMWaterBell_vibrato_rate chnget "gk_FMWaterBell_vibrato_rate"

    gk_Bower_level chnget "gk_Bower_level"
    gk_Bower_pressure chnget "gk_Bower_pressure"

    gk_Blower_grainDensity chnget "gk_Blower_grainDensity"
    gk_Blower_grainDuration chnget "gk_Blower_grainDuration"
    gk_Blower_grainAmplitudeRange chnget "gk_Blower_grainAmplitudeRange"
    gk_Blower_grainFrequencyRange chnget "gk_Blower_grainFrequencyRange"
    gk_Blower_level chnget "gk_Blower_level"

    gk_Buzzer_harmonics chnget "gk_Buzzer_harmonics"
    gk_Buzzer_level chnget "gk_Buzzer_level"

    gk_Droner_partial1 chnget "gk_Droner_partial1"
    gk_Droner_partial2 chnget "gk_Droner_partial2"
    gk_Droner_partial3 chnget "gk_Droner_partial3"
    gk_Droner_partial4 chnget "gk_Droner_partial4"
    gk_Droner_partial5 chnget "gk_Droner_partial5"
    gk_Droner_level chnget "gk_Droner_level"

    gk_Phaser_ratio1 chnget "gk_Phaser_ratio1"
    gk_Phaser_ratio2 chnget "gk_Phaser_ratio2"
    gk_Phaser_index1 chnget "gk_Phaser_index1"
    gk_Phaser_index2 chnget "gk_Phaser_index2"
    gk_Phaser_level chnget "gk_Phaser_level"

    gk_PianoteqOut_level chnget "gk_PianoteqOut_level"

    gk_Shiner_level chnget "gk_Shiner_level"

    gk_Sweeper_britel chnget "gk_Sweeper_britel"
    gk_Sweeper_briteh chnget "gk_Sweeper_briteh"
    gk_Sweeper_britels chnget "gk_Sweeper_britels"
    gk_Sweeper_britehs chnget "gk_Sweeper_britehs"
    gk_Sweeper_level chnget "gk_Sweeper_level"

    gk_ZakianFlute_level chnget "gk_ZakianFlute_level"

    gk_Reverb_feedback chnget "gk_Reverb_feedback"
    gk_Reverb2_feedback chnget "gk_Reverb2_feedback"
    gk_MasterOutput_level chnget "gk_MasterOutput_level"
    gk_overlap chnget "gk_overlap"
    goto return_label
off_label:
prints "Controls off   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
return_label:
endin

</CsInstruments>
<CsScore>
f 0 [ 180 + 15 ]
</CsScore>
</CsoundSynthesizer>
</textarea>
</body>
</html>
